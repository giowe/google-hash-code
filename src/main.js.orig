'use strict';
const u = require('./modules/utils');
const m = require('mathjs');
const initialState = require('./parsedIn');
const sampleOut = require('./samples/output');
const validation = require('./validation');
const scorer = require('./scorer');
const argv = require('yargs').argv;
const outParser = require('./outParser');

const {
  R, C, L, H, pizza
} = initialState;

const minSlices = Math.floor(R*C/H);
const toppingsCount = {
  T: 0,
  M: 0
};

const pizzaMap = [];

pizza.forEach((row, r) => {
  pizzaMap.push([]);
  row.forEach((topping, c) => {
    pizzaMap[r].push(0);
    toppingsCount[topping]++
  });
});

const minorTopping = toppingsCount.T < toppingsCount.M ? 'T' : 'M';
const maxTopping = minorTopping === 'M' ? 'T' : 'M';

const maxSlices = Math.floor(toppingsCount[minorTopping] / L);

//**************************** HELPER FUNCTIONS ****************************
function sliceArea(r1, c1, r2, c2) {
  const r = 1 + r2 - r1;
  const c = 1 + c2 - c1;
  return r*c;
}

function sliceToppings(r1, c1, r2, c2) {
  const toppings = {
    M: 0,
    T: 0
  };

  for (let r = r1; r <= r2; r++ ) {
    for (let c = c1; c <= c2; c++ ) toppings[pizza[r][c]]++;
  }

  return toppings;
}

function getUniqueRandoms(min, max, count) {
  const arr = [];
  while(arr.length < count){
    const randomnumber = min -1 + Math.ceil(Math.random()*(max-min));
    if(arr.indexOf(randomnumber) > -1) continue;
    arr[arr.length] = randomnumber;
  }
  return arr;
}

function getScore(slice){
  const t = slice.toppings;
  if ( slice.feasible ) {
   const area = slice.area;
   return area;
  }

  return -Math.abs(t.M - L) -Math.abs(t.T - L);
}

function isOnPizza(slice) {
  if( slice.r1 < 0 || slice.r1 > R-1) return false;
  if( slice.r2 < 0 || slice.r2 > R-1) return false;
  if( slice.c1 < 0 || slice.c1 > C-1) return false;
  if( slice.c2 < 0 || slice.c2 > C-1) return false;
  return true;
}

function getOverlapping(slice) {
  const a = [];
  for(let r = slice.r1; r <= slice.r2; ++r){
    for(let c = slice.c1; c <= slice.c2; ++c){
      if( pizzaMap[r][c] !== 0 && pizzaMap[r][c] !== slice.id ){

        if( slices[ pizzaMap[r][c] - 1 ].dead == false )
        	a.push(pizzaMap[r][c]);
      
      }
    }
  }

  const unique = a.filter(function(item, i, ar){ return ar.indexOf(item) === i; });
  return unique;
}

function printPizzaMap(){
	for(let r = 0; r < R; ++r){
		console.log( pizzaMap[r] );
	}
	console.log('')
}
//**************************** SLICE CLASS ****************************
class Slice {
  constructor(id, r1, c1, r2 = r1, c2 = c1) {
    this.id = id;
    this.r1 = r1;
    this.c1 = c1;
    this.r2 = r2;
    this.c2 = c2;
    this.dead = false;
    this.apply();
    return this;
  }

  get feasible(){
  	const t = this.toppings;
  	if( t.T >= L && t.M >= L && this.area <= H ) 
  		return true;
  	return false;
  }

  get h() {
    return 1 + this.r2 - this.r1;
  }

  get w() {
    return 1 + this.c2 - this.c1;
  }

  get area() {
    return this.h * this.w;
  }

  get score() {
    return getScore(this);
  }

  get toppings() {
    return sliceToppings(this.r1, this.c1, this.r2, this.c2);
  }

  isOnPizza() {
    return isOnPizza(this);
  }

  getOverlapping() {
    return getOverlapping(this);
  }


  enlarge(direction) {
    switch (direction.toUpperCase()) {
      case 'U':
        this.r1--;
        break;
      case 'D':
        this.r2++;
        break;
      case 'L':
        this.c1--;
        break;
      case 'R':
        this.c2++;
        break;

    }
  }

  apply(){
    for(let r = this.r1; r <= this.r2; ++r){
      for(let c = this.c1; c <= this.c2; ++c){
          pizzaMap[r][c] = this.id;
      }
    }
  }

}

//**************************** PROCESS OPERATIONS ****************************

//SEEDS GENERATION
const minToppingCoords = [];
pizza.forEach((row, r) => {
  row.forEach((topping, c) => {
    if (topping === maxTopping) return;
    minToppingCoords.push([r, c]);
  });
});

const slices = [];
const dir = ['U', 'D', 'L', 'R'];

getUniqueRandoms(0, minToppingCoords.length, maxSlices).forEach((rnd, i) => {
  const coords = minToppingCoords[rnd];
  slices.push(new Slice(i+1, coords[0], coords[1]))
});


let moved = true;
let turnsCount = 0;
while(moved) {
  turnsCount++;
  moved = false;

  slices.forEach((slice) => {
    const score = slice.score;
    let maxDir = '';
    let maxScore = score;
    let overlap = [];

    if(slice.dead) return;

    dir.forEach( (d) => {
      const sliceClone = u.clone(slice);
      let can_be_conquered = false;
      
      sliceClone.enlarge(d);

      if (sliceClone.area > H){
        return;
      }

      if ( !sliceClone.isOnPizza() ){
        return;
      }

      let overlappingList = sliceClone.getOverlapping();

      if (overlappingList.length > 0) {
        
        for(let i = 0; i < overlappingList.length; ++i){
        	if( slices[ overlappingList[i] - 1].feasible == true ){
        		return;
        	} 
        }

        can_be_conquered = true;

      }

      const cloneScore = sliceClone.score;

      //console.log(sliceClone, cloneScore, d);

      if (maxScore < cloneScore) {
        maxScore = cloneScore;
        maxDir = d;

        if(can_be_conquered) 
        	overlap = overlappingList;
      }

    });

    if (maxDir) {
    	slice.enlarge(maxDir);
     	slice.apply();
    	moved = true;


      for(let i = 0; i < overlap.length; ++i){
      	slices[ overlap[i] - 1 ].dead = true;
      }

      overlap = [];
    }

  });

}

console.log('TURNS:', turnsCount);
// u.logJson(slices);
// slices.forEach((s) => console.log(s, s.feasible, s.score));

const out = [];
slices.forEach((s) => {
  if (s.feasible) {
    out.push({
      r1: s.r1,
      c1: s.c1,
      r2: s.r2,
      c2: s.c2
    });
  }
});

console.log("Current number of slices is: " + out.length );
console.log("Maximum number of slices is: " + maxSlices );
console.log("Perc: " + out.length / maxSlices * 100  + "%");

//console.log(out);

module.exports = out;

//eseguire il programma scrivendo -V per avviare la validation
if (argv.V || argv.validation) {
  validation.runTests(initialState, out);
}

const finalScore = scorer(initialState, out);
u.logColor('green', '\nScore: ' + finalScore);
outParser.produceOutput(finalScore, out);
